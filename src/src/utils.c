/* utils.c generated by valac 0.32.0.61-f103e, the Vala compiler
 * generated from utils.vala, do not modify */

/*
 * Copyright (C) 2013  Paolo Borelli <pborelli@gnome.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <gdk/gdk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include "config.h"
#include <float.h>
#include <math.h>
#include "libgnome-desktop/gnome-wall-clock.h"
#include <glib/gi18n-lib.h>
#include <gsound.h>
#include <gobject/gvaluecollector.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define CLOCKS_UTILS_TYPE_WALL_CLOCK (clocks_utils_wall_clock_get_type ())
#define CLOCKS_UTILS_WALL_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClock))
#define CLOCKS_UTILS_WALL_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClockClass))
#define CLOCKS_UTILS_IS_WALL_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_UTILS_TYPE_WALL_CLOCK))
#define CLOCKS_UTILS_IS_WALL_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_UTILS_TYPE_WALL_CLOCK))
#define CLOCKS_UTILS_WALL_CLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClockClass))

typedef struct _ClocksUtilsWallClock ClocksUtilsWallClock;
typedef struct _ClocksUtilsWallClockClass ClocksUtilsWallClockClass;
typedef struct _ClocksUtilsWallClockPrivate ClocksUtilsWallClockPrivate;

#define CLOCKS_UTILS_WALL_CLOCK_TYPE_FORMAT (clocks_utils_wall_clock_format_get_type ())
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))
#define _g_time_zone_unref0(var) ((var == NULL) ? NULL : (var = (g_time_zone_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

#define CLOCKS_UTILS_TYPE_WEEKDAYS (clocks_utils_weekdays_get_type ())
#define CLOCKS_UTILS_WEEKDAYS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_UTILS_TYPE_WEEKDAYS, ClocksUtilsWeekdays))
#define CLOCKS_UTILS_WEEKDAYS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_UTILS_TYPE_WEEKDAYS, ClocksUtilsWeekdaysClass))
#define CLOCKS_UTILS_IS_WEEKDAYS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_UTILS_TYPE_WEEKDAYS))
#define CLOCKS_UTILS_IS_WEEKDAYS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_UTILS_TYPE_WEEKDAYS))
#define CLOCKS_UTILS_WEEKDAYS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_UTILS_TYPE_WEEKDAYS, ClocksUtilsWeekdaysClass))

typedef struct _ClocksUtilsWeekdays ClocksUtilsWeekdays;
typedef struct _ClocksUtilsWeekdaysClass ClocksUtilsWeekdaysClass;
typedef struct _ClocksUtilsWeekdaysPrivate ClocksUtilsWeekdaysPrivate;

#define CLOCKS_UTILS_WEEKDAYS_TYPE_DAY (clocks_utils_weekdays_day_get_type ())
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_variant_builder_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_builder_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_variant_iter_free0(var) ((var == NULL) ? NULL : (var = (g_variant_iter_free (var), NULL)))
#define _clocks_utils_weekdays_unref0(var) ((var == NULL) ? NULL : (var = (clocks_utils_weekdays_unref (var), NULL)))
typedef struct _ClocksUtilsParamSpecWeekdays ClocksUtilsParamSpecWeekdays;

#define CLOCKS_UTILS_TYPE_BELL (clocks_utils_bell_get_type ())
#define CLOCKS_UTILS_BELL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBell))
#define CLOCKS_UTILS_BELL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBellClass))
#define CLOCKS_UTILS_IS_BELL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLOCKS_UTILS_TYPE_BELL))
#define CLOCKS_UTILS_IS_BELL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLOCKS_UTILS_TYPE_BELL))
#define CLOCKS_UTILS_BELL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBellClass))

typedef struct _ClocksUtilsBell ClocksUtilsBell;
typedef struct _ClocksUtilsBellClass ClocksUtilsBellClass;
typedef struct _ClocksUtilsBellPrivate ClocksUtilsBellPrivate;
typedef struct _ClocksUtilsBellRingRealData ClocksUtilsBellRingRealData;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _ClocksUtilsWallClock {
	GObject parent_instance;
	ClocksUtilsWallClockPrivate * priv;
};

struct _ClocksUtilsWallClockClass {
	GObjectClass parent_class;
};

typedef enum  {
	CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWELVE,
	CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWENTYFOUR
} ClocksUtilsWallClockFormat;

struct _ClocksUtilsWallClockPrivate {
	GDateTime* _date_time;
	GTimeZone* _timezone;
	ClocksUtilsWallClockFormat _format;
	GSettings* settings;
	GnomeWallClock* wc;
};

struct _ClocksUtilsWeekdays {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ClocksUtilsWeekdaysPrivate * priv;
};

struct _ClocksUtilsWeekdaysClass {
	GTypeClass parent_class;
	void (*finalize) (ClocksUtilsWeekdays *self);
};

struct _ClocksUtilsWeekdaysPrivate {
	gboolean* days;
	gint days_length1;
	gint _days_size_;
};

typedef enum  {
	CLOCKS_UTILS_WEEKDAYS_DAY_MON,
	CLOCKS_UTILS_WEEKDAYS_DAY_TUE,
	CLOCKS_UTILS_WEEKDAYS_DAY_WED,
	CLOCKS_UTILS_WEEKDAYS_DAY_THU,
	CLOCKS_UTILS_WEEKDAYS_DAY_FRI,
	CLOCKS_UTILS_WEEKDAYS_DAY_SAT,
	CLOCKS_UTILS_WEEKDAYS_DAY_SUN
} ClocksUtilsWeekdaysDay;

struct _ClocksUtilsParamSpecWeekdays {
	GParamSpec parent_instance;
};

struct _ClocksUtilsBell {
	GObject parent_instance;
	ClocksUtilsBellPrivate * priv;
};

struct _ClocksUtilsBellClass {
	GObjectClass parent_class;
};

struct _ClocksUtilsBellPrivate {
	GSettings* settings;
	GSoundContext* gsound;
	GCancellable* cancellable;
	gchar* soundtheme;
	gchar* sound;
};

struct _ClocksUtilsBellRingRealData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	ClocksUtilsBell* self;
	gboolean repeat;
	GSoundContext* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GSoundContext* _tmp3_;
	GCancellable* _tmp4_;
	const gchar* _tmp5_;
	const gchar* _tmp6_;
	GError* e;
	GError* _vala1_e;
	GError* _tmp7_;
	const gchar* _tmp8_;
	GError * _inner_error_;
};


static gpointer clocks_utils_wall_clock_parent_class = NULL;
static ClocksUtilsWallClock* clocks_utils_wall_clock_instance;
static ClocksUtilsWallClock* clocks_utils_wall_clock_instance = NULL;
static gpointer clocks_utils_weekdays_parent_class = NULL;
static gchar** clocks_utils_weekdays_abbreviations;
static gint clocks_utils_weekdays_abbreviations_length1;
static gchar** clocks_utils_weekdays_abbreviations = NULL;
static gint clocks_utils_weekdays_abbreviations_length1 = 0;
static gint _clocks_utils_weekdays_abbreviations_size_ = 0;
static gpointer clocks_utils_bell_parent_class = NULL;

gint clocks_cutils_get_week_start (void);
void clocks_utils_load_css (const gchar* css, gboolean required);
void clocks_utils_load_main_css (void);
void clocks_utils_load_theme_css (const gchar* theme_name);
GdkPixbuf* clocks_utils_load_image (const gchar* image);
void clocks_utils_time_to_hms (gdouble t, gint* h, gint* m, gint* s, gdouble* remainder);
GType clocks_utils_wall_clock_get_type (void) G_GNUC_CONST;
GType clocks_utils_wall_clock_format_get_type (void) G_GNUC_CONST;
#define CLOCKS_UTILS_WALL_CLOCK_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClockPrivate))
enum  {
	CLOCKS_UTILS_WALL_CLOCK_DUMMY_PROPERTY,
	CLOCKS_UTILS_WALL_CLOCK_DATE_TIME,
	CLOCKS_UTILS_WALL_CLOCK_TIMEZONE,
	CLOCKS_UTILS_WALL_CLOCK_FORMAT
};
ClocksUtilsWallClock* clocks_utils_wall_clock_get_default (void);
static ClocksUtilsWallClock* clocks_utils_wall_clock_new (void);
static ClocksUtilsWallClock* clocks_utils_wall_clock_construct (GType object_type);
static void __lambda5_ (ClocksUtilsWallClock* self);
static void clocks_utils_wall_clock_update (ClocksUtilsWallClock* self);
static void ___lambda5__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void clocks_utils_wall_clock_set_timezone (ClocksUtilsWallClock* self, GTimeZone* value);
static void __lambda6_ (ClocksUtilsWallClock* self);
static void ___lambda6__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self);
static void __lambda7_ (ClocksUtilsWallClock* self);
static void clocks_utils_wall_clock_update_format (ClocksUtilsWallClock* self);
static void ___lambda7__g_settings_changed (GSettings* _sender, const gchar* key, gpointer self);
static void clocks_utils_wall_clock_set_format (ClocksUtilsWallClock* self, ClocksUtilsWallClockFormat value);
GTimeZone* clocks_utils_wall_clock_get_timezone (ClocksUtilsWallClock* self);
static void clocks_utils_wall_clock_set_date_time (ClocksUtilsWallClock* self, GDateTime* value);
gchar* clocks_utils_wall_clock_format_time (ClocksUtilsWallClock* self, GDateTime* date_time);
ClocksUtilsWallClockFormat clocks_utils_wall_clock_get_format (ClocksUtilsWallClock* self);
GDateTime* clocks_utils_wall_clock_get_date_time (ClocksUtilsWallClock* self);
static void clocks_utils_wall_clock_finalize (GObject* obj);
static void _vala_clocks_utils_wall_clock_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_clocks_utils_wall_clock_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gpointer clocks_utils_weekdays_ref (gpointer instance);
void clocks_utils_weekdays_unref (gpointer instance);
GParamSpec* clocks_utils_param_spec_weekdays (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void clocks_utils_value_set_weekdays (GValue* value, gpointer v_object);
void clocks_utils_value_take_weekdays (GValue* value, gpointer v_object);
gpointer clocks_utils_value_get_weekdays (const GValue* value);
GType clocks_utils_weekdays_get_type (void) G_GNUC_CONST;
#define CLOCKS_UTILS_WEEKDAYS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CLOCKS_UTILS_TYPE_WEEKDAYS, ClocksUtilsWeekdaysPrivate))
enum  {
	CLOCKS_UTILS_WEEKDAYS_DUMMY_PROPERTY
};
GType clocks_utils_weekdays_day_get_type (void) G_GNUC_CONST;
ClocksUtilsWeekdaysDay clocks_utils_weekdays_get_first_weekday (void);
gchar* clocks_utils_weekdays_plural (ClocksUtilsWeekdaysDay d);
gchar* clocks_utils_weekdays_abbreviation (ClocksUtilsWeekdaysDay d);
ClocksUtilsWeekdays* clocks_utils_weekdays_new (void);
ClocksUtilsWeekdays* clocks_utils_weekdays_construct (GType object_type);
static gboolean clocks_utils_weekdays_days_equal (ClocksUtilsWeekdays* self, gboolean* d, int d_length1);
gboolean clocks_utils_weekdays_get (ClocksUtilsWeekdays* self, ClocksUtilsWeekdaysDay d);
void clocks_utils_weekdays_set (ClocksUtilsWeekdays* self, ClocksUtilsWeekdaysDay d, gboolean on);
gchar* clocks_utils_weekdays_get_label (ClocksUtilsWeekdays* self);
static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value);
GVariant* clocks_utils_weekdays_serialize (ClocksUtilsWeekdays* self);
ClocksUtilsWeekdays* clocks_utils_weekdays_deserialize (GVariant* days_variant);
gboolean clocks_utils_weekdays_get_empty (ClocksUtilsWeekdays* self);
static void clocks_utils_weekdays_finalize (ClocksUtilsWeekdays* obj);
GType clocks_utils_bell_get_type (void) G_GNUC_CONST;
#define CLOCKS_UTILS_BELL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBellPrivate))
enum  {
	CLOCKS_UTILS_BELL_DUMMY_PROPERTY
};
ClocksUtilsBell* clocks_utils_bell_new (const gchar* soundid);
ClocksUtilsBell* clocks_utils_bell_construct (GType object_type, const gchar* soundid);
static void clocks_utils_bell_ring_real_data_free (gpointer _data);
static void clocks_utils_bell_ring_real (ClocksUtilsBell* self, gboolean repeat, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void clocks_utils_bell_ring_real_finish (ClocksUtilsBell* self, GAsyncResult* _res_);
static gboolean clocks_utils_bell_ring_real_co (ClocksUtilsBellRingRealData* _data_);
static void clocks_utils_bell_ring_real_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void clocks_utils_bell_ring_once (ClocksUtilsBell* self);
void clocks_utils_bell_ring (ClocksUtilsBell* self);
void clocks_utils_bell_stop (ClocksUtilsBell* self);
static void clocks_utils_bell_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);

static const gboolean CLOCKS_UTILS_WEEKDAYS_weekdays[7] = {TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE};
static const gboolean CLOCKS_UTILS_WEEKDAYS_weekends[7] = {FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE};
static const gchar* CLOCKS_UTILS_WEEKDAYS_plurals[7] = {"Mondays", "Tuesdays", "Wednesdays", "Thursdays", "Fridays", "Saturdays", "Sundays"};

void clocks_utils_load_css (const gchar* css, gboolean required) {
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp0_ = NULL;
	GdkScreen* _tmp13_ = NULL;
	GtkCssProvider* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (css != NULL);
	_tmp0_ = gtk_css_provider_new ();
	provider = _tmp0_;
	{
		GFile* file = NULL;
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GFile* _tmp6_ = NULL;
		GFile* _tmp7_ = NULL;
		GtkCssProvider* _tmp8_ = NULL;
		GFile* _tmp9_ = NULL;
		_tmp1_ = css;
		_tmp2_ = g_strconcat ("resource:///org/gnome/clocks/css/", _tmp1_, NULL);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_strconcat (_tmp3_, ".css", NULL);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_file_new_for_uri (_tmp5_);
		_tmp7_ = _tmp6_;
		_g_free0 (_tmp5_);
		_g_free0 (_tmp3_);
		file = _tmp7_;
		_tmp8_ = provider;
		_tmp9_ = file;
		gtk_css_provider_load_from_file (_tmp8_, _tmp9_, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch2_g_error;
		}
		_g_object_unref0 (file);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		gboolean _tmp10_ = FALSE;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp10_ = required;
		if (_tmp10_) {
			GError* _tmp11_ = NULL;
			const gchar* _tmp12_ = NULL;
			_tmp11_ = e;
			_tmp12_ = _tmp11_->message;
			g_warning ("utils.vala:31: loading css: %s", _tmp12_);
		}
		_g_error_free0 (e);
		_g_object_unref0 (provider);
		return;
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (provider);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp13_ = gdk_screen_get_default ();
	_tmp14_ = provider;
	gtk_style_context_add_provider_for_screen (_tmp13_, (GtkStyleProvider*) _tmp14_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	_g_object_unref0 (provider);
}


void clocks_utils_load_main_css (void) {
	clocks_utils_load_css ("gnome-clocks", TRUE);
}


void clocks_utils_load_theme_css (const gchar* theme_name) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	g_return_if_fail (theme_name != NULL);
	_tmp0_ = theme_name;
	_tmp1_ = g_utf8_strdown (_tmp0_, (gssize) -1);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat ("gnome-clocks.", _tmp2_, NULL);
	_tmp4_ = _tmp3_;
	clocks_utils_load_css (_tmp4_, FALSE);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
}


GdkPixbuf* clocks_utils_load_image (const gchar* image) {
	GdkPixbuf* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (image != NULL, NULL);
	{
		gchar* path = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		GdkPixbuf* _tmp2_ = NULL;
		GdkPixbuf* _tmp3_ = NULL;
		GdkPixbuf* _tmp4_ = NULL;
		_tmp0_ = image;
		_tmp1_ = g_build_filename (DATADIR, "gnome-clocks", "images", _tmp0_, NULL);
		path = _tmp1_;
		_tmp3_ = gdk_pixbuf_new_from_file (path, &_inner_error_);
		_tmp2_ = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (path);
			goto __catch3_g_error;
		}
		_tmp4_ = _tmp2_;
		_tmp2_ = NULL;
		result = _tmp4_;
		_g_object_unref0 (_tmp2_);
		_g_free0 (path);
		return result;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		GError* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = e;
		_tmp6_ = _tmp5_->message;
		g_warning ("utils.vala:55: loading image file: %s", _tmp6_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = NULL;
	return result;
}


void clocks_utils_time_to_hms (gdouble t, gint* h, gint* m, gint* s, gdouble* remainder) {
	gint _vala_h = 0;
	gint _vala_m = 0;
	gint _vala_s = 0;
	gdouble _vala_remainder = 0.0;
	gdouble _tmp0_ = 0.0;
	gdouble _tmp1_ = 0.0;
	gdouble _tmp2_ = 0.0;
	gdouble _tmp3_ = 0.0;
	gdouble _tmp4_ = 0.0;
	gdouble _tmp5_ = 0.0;
	_tmp0_ = t;
	_vala_h = ((gint) _tmp0_) / 3600;
	_tmp1_ = t;
	t = fmod (_tmp1_, 3600);
	_tmp2_ = t;
	_vala_m = ((gint) _tmp2_) / 60;
	_tmp3_ = t;
	t = fmod (_tmp3_, 60);
	_tmp4_ = t;
	_vala_s = (gint) _tmp4_;
	_tmp5_ = t;
	_vala_remainder = _tmp5_ - _vala_s;
	if (h) {
		*h = _vala_h;
	}
	if (m) {
		*m = _vala_m;
	}
	if (s) {
		*s = _vala_s;
	}
	if (remainder) {
		*remainder = _vala_remainder;
	}
}


GType clocks_utils_wall_clock_format_get_type (void) {
	static volatile gsize clocks_utils_wall_clock_format_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_utils_wall_clock_format_type_id__volatile)) {
		static const GEnumValue values[] = {{CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWELVE, "CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWELVE", "twelve"}, {CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWENTYFOUR, "CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWENTYFOUR", "twentyfour"}, {0, NULL, NULL}};
		GType clocks_utils_wall_clock_format_type_id;
		clocks_utils_wall_clock_format_type_id = g_enum_register_static ("ClocksUtilsWallClockFormat", values);
		g_once_init_leave (&clocks_utils_wall_clock_format_type_id__volatile, clocks_utils_wall_clock_format_type_id);
	}
	return clocks_utils_wall_clock_format_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


ClocksUtilsWallClock* clocks_utils_wall_clock_get_default (void) {
	ClocksUtilsWallClock* result = NULL;
	ClocksUtilsWallClock* _tmp0_ = NULL;
	ClocksUtilsWallClock* _tmp2_ = NULL;
	ClocksUtilsWallClock* _tmp3_ = NULL;
	_tmp0_ = clocks_utils_wall_clock_instance;
	if (_tmp0_ == NULL) {
		ClocksUtilsWallClock* _tmp1_ = NULL;
		_tmp1_ = clocks_utils_wall_clock_new ();
		_g_object_unref0 (clocks_utils_wall_clock_instance);
		clocks_utils_wall_clock_instance = _tmp1_;
	}
	_tmp2_ = clocks_utils_wall_clock_instance;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static void __lambda5_ (ClocksUtilsWallClock* self) {
	clocks_utils_wall_clock_update (self);
	g_signal_emit_by_name (self, "tick");
}


static void ___lambda5__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda5_ ((ClocksUtilsWallClock*) self);
}


static void __lambda6_ (ClocksUtilsWallClock* self) {
	GnomeWallClock* _tmp0_ = NULL;
	GTimeZone* _tmp1_ = NULL;
	GTimeZone* _tmp2_ = NULL;
	GTimeZone* _tmp3_ = NULL;
	_tmp0_ = self->priv->wc;
	g_object_get (_tmp0_, "timezone", &_tmp1_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_;
	clocks_utils_wall_clock_set_timezone (self, _tmp3_);
	_g_time_zone_unref0 (_tmp3_);
}


static void ___lambda6__g_object_notify (GObject* _sender, GParamSpec* pspec, gpointer self) {
	__lambda6_ ((ClocksUtilsWallClock*) self);
}


static void __lambda7_ (ClocksUtilsWallClock* self) {
	clocks_utils_wall_clock_update_format (self);
}


static void ___lambda7__g_settings_changed (GSettings* _sender, const gchar* key, gpointer self) {
	__lambda7_ ((ClocksUtilsWallClock*) self);
}


static ClocksUtilsWallClock* clocks_utils_wall_clock_construct (GType object_type) {
	ClocksUtilsWallClock * self = NULL;
	GnomeWallClock* _tmp0_ = NULL;
	GnomeWallClock* _tmp1_ = NULL;
	GnomeWallClock* _tmp2_ = NULL;
	GTimeZone* _tmp3_ = NULL;
	GTimeZone* _tmp4_ = NULL;
	GTimeZone* _tmp5_ = NULL;
	GnomeWallClock* _tmp6_ = NULL;
	GSettings* _tmp7_ = NULL;
	GSettings* _tmp8_ = NULL;
	self = (ClocksUtilsWallClock*) g_object_new (object_type, NULL);
	_tmp0_ = gnome_wall_clock_new ();
	_g_object_unref0 (self->priv->wc);
	self->priv->wc = _tmp0_;
	_tmp1_ = self->priv->wc;
	g_signal_connect_object ((GObject*) _tmp1_, "notify::clock", (GCallback) ___lambda5__g_object_notify, self, 0);
	_tmp2_ = self->priv->wc;
	g_object_get (_tmp2_, "timezone", &_tmp3_, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	clocks_utils_wall_clock_set_timezone (self, _tmp5_);
	_g_time_zone_unref0 (_tmp5_);
	_tmp6_ = self->priv->wc;
	g_signal_connect_object ((GObject*) _tmp6_, "notify::timezone", (GCallback) ___lambda6__g_object_notify, self, 0);
	_tmp7_ = g_settings_new ("org.gnome.desktop.interface");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp7_;
	_tmp8_ = self->priv->settings;
	g_signal_connect_object (_tmp8_, "changed::clock-format", (GCallback) ___lambda7__g_settings_changed, self, 0);
	clocks_utils_wall_clock_update_format (self);
	clocks_utils_wall_clock_update (self);
	return self;
}


static ClocksUtilsWallClock* clocks_utils_wall_clock_new (void) {
	return clocks_utils_wall_clock_construct (CLOCKS_UTILS_TYPE_WALL_CLOCK);
}


static void clocks_utils_wall_clock_update_format (ClocksUtilsWallClock* self) {
	gchar* sys_format = NULL;
	GSettings* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	ClocksUtilsWallClockFormat _tmp2_ = 0;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->settings;
	_tmp1_ = g_settings_get_string (_tmp0_, "clock-format");
	sys_format = _tmp1_;
	_tmp3_ = sys_format;
	if (g_strcmp0 (_tmp3_, "12h") == 0) {
		_tmp2_ = CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWELVE;
	} else {
		_tmp2_ = CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWENTYFOUR;
	}
	clocks_utils_wall_clock_set_format (self, _tmp2_);
	_g_free0 (sys_format);
}


static void clocks_utils_wall_clock_update (ClocksUtilsWallClock* self) {
	GTimeZone* _tmp0_ = NULL;
	GDateTime* _tmp1_ = NULL;
	GDateTime* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_timezone;
	_tmp1_ = g_date_time_new_now (_tmp0_);
	_tmp2_ = _tmp1_;
	clocks_utils_wall_clock_set_date_time (self, _tmp2_);
	_g_date_time_unref0 (_tmp2_);
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch4_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) -1, 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch4_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally4;
	__catch4_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


gchar* clocks_utils_wall_clock_format_time (ClocksUtilsWallClock* self, GDateTime* date_time) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	ClocksUtilsWallClockFormat _tmp1_ = 0;
	gchar* time = NULL;
	GDateTime* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	ClocksUtilsWallClockFormat _tmp6_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (date_time != NULL, NULL);
	_tmp1_ = self->priv->_format;
	if (_tmp1_ == CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWELVE) {
		_tmp0_ = "%I:%M %p";
	} else {
		_tmp0_ = "%H:%M";
	}
	_tmp2_ = date_time;
	_tmp3_ = g_date_time_format (_tmp2_, _tmp0_);
	time = _tmp3_;
	_tmp4_ = time;
	_tmp5_ = string_replace (_tmp4_, ":", "\xE2\x80\x8E\xE2\x88\xB6");
	_g_free0 (time);
	time = _tmp5_;
	_tmp6_ = self->priv->_format;
	if (_tmp6_ == CLOCKS_UTILS_WALL_CLOCK_FORMAT_TWELVE) {
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		_tmp7_ = time;
		_tmp8_ = string_replace (_tmp7_, " ", "\xE2\x80\x89");
		_g_free0 (time);
		time = _tmp8_;
	}
	result = time;
	return result;
}


GDateTime* clocks_utils_wall_clock_get_date_time (ClocksUtilsWallClock* self) {
	GDateTime* result;
	GDateTime* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_date_time;
	result = _tmp0_;
	return result;
}


static gpointer _g_date_time_ref0 (gpointer self) {
	return self ? g_date_time_ref (self) : NULL;
}


static void clocks_utils_wall_clock_set_date_time (ClocksUtilsWallClock* self, GDateTime* value) {
	GDateTime* _tmp0_ = NULL;
	GDateTime* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_date_time_ref0 (_tmp0_);
	_g_date_time_unref0 (self->priv->_date_time);
	self->priv->_date_time = _tmp1_;
	g_object_notify ((GObject *) self, "date-time");
}


GTimeZone* clocks_utils_wall_clock_get_timezone (ClocksUtilsWallClock* self) {
	GTimeZone* result;
	GTimeZone* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_timezone;
	result = _tmp0_;
	return result;
}


static gpointer _g_time_zone_ref0 (gpointer self) {
	return self ? g_time_zone_ref (self) : NULL;
}


static void clocks_utils_wall_clock_set_timezone (ClocksUtilsWallClock* self, GTimeZone* value) {
	GTimeZone* _tmp0_ = NULL;
	GTimeZone* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_time_zone_ref0 (_tmp0_);
	_g_time_zone_unref0 (self->priv->_timezone);
	self->priv->_timezone = _tmp1_;
	g_object_notify ((GObject *) self, "timezone");
}


ClocksUtilsWallClockFormat clocks_utils_wall_clock_get_format (ClocksUtilsWallClock* self) {
	ClocksUtilsWallClockFormat result;
	ClocksUtilsWallClockFormat _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_format;
	result = _tmp0_;
	return result;
}


static void clocks_utils_wall_clock_set_format (ClocksUtilsWallClock* self, ClocksUtilsWallClockFormat value) {
	ClocksUtilsWallClockFormat _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_format = _tmp0_;
	g_object_notify ((GObject *) self, "format");
}


static void clocks_utils_wall_clock_class_init (ClocksUtilsWallClockClass * klass) {
	clocks_utils_wall_clock_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ClocksUtilsWallClockPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_clocks_utils_wall_clock_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_clocks_utils_wall_clock_set_property;
	G_OBJECT_CLASS (klass)->finalize = clocks_utils_wall_clock_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_UTILS_WALL_CLOCK_DATE_TIME, g_param_spec_boxed ("date-time", "date-time", "date-time", G_TYPE_DATE_TIME, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_UTILS_WALL_CLOCK_TIMEZONE, g_param_spec_pointer ("timezone", "timezone", "timezone", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), CLOCKS_UTILS_WALL_CLOCK_FORMAT, g_param_spec_enum ("format", "format", "format", CLOCKS_UTILS_WALL_CLOCK_TYPE_FORMAT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("tick", CLOCKS_UTILS_TYPE_WALL_CLOCK, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void clocks_utils_wall_clock_instance_init (ClocksUtilsWallClock * self) {
	self->priv = CLOCKS_UTILS_WALL_CLOCK_GET_PRIVATE (self);
}


static void clocks_utils_wall_clock_finalize (GObject* obj) {
	ClocksUtilsWallClock * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClock);
	_g_date_time_unref0 (self->priv->_date_time);
	_g_time_zone_unref0 (self->priv->_timezone);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->wc);
	G_OBJECT_CLASS (clocks_utils_wall_clock_parent_class)->finalize (obj);
}


GType clocks_utils_wall_clock_get_type (void) {
	static volatile gsize clocks_utils_wall_clock_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_utils_wall_clock_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClocksUtilsWallClockClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) clocks_utils_wall_clock_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClocksUtilsWallClock), 0, (GInstanceInitFunc) clocks_utils_wall_clock_instance_init, NULL };
		GType clocks_utils_wall_clock_type_id;
		clocks_utils_wall_clock_type_id = g_type_register_static (G_TYPE_OBJECT, "ClocksUtilsWallClock", &g_define_type_info, 0);
		g_once_init_leave (&clocks_utils_wall_clock_type_id__volatile, clocks_utils_wall_clock_type_id);
	}
	return clocks_utils_wall_clock_type_id__volatile;
}


static void _vala_clocks_utils_wall_clock_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	ClocksUtilsWallClock * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClock);
	switch (property_id) {
		case CLOCKS_UTILS_WALL_CLOCK_DATE_TIME:
		g_value_set_boxed (value, clocks_utils_wall_clock_get_date_time (self));
		break;
		case CLOCKS_UTILS_WALL_CLOCK_TIMEZONE:
		g_value_set_pointer (value, clocks_utils_wall_clock_get_timezone (self));
		break;
		case CLOCKS_UTILS_WALL_CLOCK_FORMAT:
		g_value_set_enum (value, clocks_utils_wall_clock_get_format (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_clocks_utils_wall_clock_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	ClocksUtilsWallClock * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, CLOCKS_UTILS_TYPE_WALL_CLOCK, ClocksUtilsWallClock);
	switch (property_id) {
		case CLOCKS_UTILS_WALL_CLOCK_DATE_TIME:
		clocks_utils_wall_clock_set_date_time (self, g_value_get_boxed (value));
		break;
		case CLOCKS_UTILS_WALL_CLOCK_TIMEZONE:
		clocks_utils_wall_clock_set_timezone (self, g_value_get_pointer (value));
		break;
		case CLOCKS_UTILS_WALL_CLOCK_FORMAT:
		clocks_utils_wall_clock_set_format (self, g_value_get_enum (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


GType clocks_utils_weekdays_day_get_type (void) {
	static volatile gsize clocks_utils_weekdays_day_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_utils_weekdays_day_type_id__volatile)) {
		static const GEnumValue values[] = {{CLOCKS_UTILS_WEEKDAYS_DAY_MON, "CLOCKS_UTILS_WEEKDAYS_DAY_MON", "mon"}, {CLOCKS_UTILS_WEEKDAYS_DAY_TUE, "CLOCKS_UTILS_WEEKDAYS_DAY_TUE", "tue"}, {CLOCKS_UTILS_WEEKDAYS_DAY_WED, "CLOCKS_UTILS_WEEKDAYS_DAY_WED", "wed"}, {CLOCKS_UTILS_WEEKDAYS_DAY_THU, "CLOCKS_UTILS_WEEKDAYS_DAY_THU", "thu"}, {CLOCKS_UTILS_WEEKDAYS_DAY_FRI, "CLOCKS_UTILS_WEEKDAYS_DAY_FRI", "fri"}, {CLOCKS_UTILS_WEEKDAYS_DAY_SAT, "CLOCKS_UTILS_WEEKDAYS_DAY_SAT", "sat"}, {CLOCKS_UTILS_WEEKDAYS_DAY_SUN, "CLOCKS_UTILS_WEEKDAYS_DAY_SUN", "sun"}, {0, NULL, NULL}};
		GType clocks_utils_weekdays_day_type_id;
		clocks_utils_weekdays_day_type_id = g_enum_register_static ("ClocksUtilsWeekdaysDay", values);
		g_once_init_leave (&clocks_utils_weekdays_day_type_id__volatile, clocks_utils_weekdays_day_type_id);
	}
	return clocks_utils_weekdays_day_type_id__volatile;
}


ClocksUtilsWeekdaysDay clocks_utils_weekdays_get_first_weekday (void) {
	ClocksUtilsWeekdaysDay result = 0;
	gint d = 0;
	gint _tmp0_ = 0;
	_tmp0_ = clocks_cutils_get_week_start ();
	d = _tmp0_;
	result = (ClocksUtilsWeekdaysDay) ((d + 6) % 7);
	return result;
}


gchar* clocks_utils_weekdays_plural (ClocksUtilsWeekdaysDay d) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	ClocksUtilsWeekdaysDay _tmp1_ = 0;
	ClocksUtilsWeekdaysDay _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	_tmp1_ = d;
	if (_tmp1_ >= 0) {
		ClocksUtilsWeekdaysDay _tmp2_ = 0;
		_tmp2_ = d;
		_tmp0_ = _tmp2_ < 7;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "d >= 0 && d < 7");
	_tmp3_ = d;
	_tmp4_ = CLOCKS_UTILS_WEEKDAYS_plurals[_tmp3_];
	_tmp5_ = _ (_tmp4_);
	_tmp6_ = g_strdup (_tmp5_);
	result = _tmp6_;
	return result;
}


gchar* clocks_utils_weekdays_abbreviation (ClocksUtilsWeekdaysDay d) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	ClocksUtilsWeekdaysDay _tmp1_ = 0;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gchar** _tmp26_ = NULL;
	gint _tmp26__length1 = 0;
	ClocksUtilsWeekdaysDay _tmp27_ = 0;
	const gchar* _tmp28_ = NULL;
	gchar* _tmp29_ = NULL;
	_tmp1_ = d;
	if (_tmp1_ >= 0) {
		ClocksUtilsWeekdaysDay _tmp2_ = 0;
		_tmp2_ = d;
		_tmp0_ = _tmp2_ < 7;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "d >= 0 && d < 7");
	_tmp3_ = clocks_utils_weekdays_abbreviations;
	_tmp3__length1 = clocks_utils_weekdays_abbreviations_length1;
	if (_tmp3_ == NULL) {
		GDateTime* _tmp4_ = NULL;
		GDateTime* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		GDateTime* _tmp7_ = NULL;
		GDateTime* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		GDateTime* _tmp10_ = NULL;
		GDateTime* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		GDateTime* _tmp13_ = NULL;
		GDateTime* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		GDateTime* _tmp16_ = NULL;
		GDateTime* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		GDateTime* _tmp19_ = NULL;
		GDateTime* _tmp20_ = NULL;
		gchar* _tmp21_ = NULL;
		GDateTime* _tmp22_ = NULL;
		GDateTime* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar** _tmp25_ = NULL;
		_tmp4_ = g_date_time_new_utc (1, 1, 1, 0, 0, (gdouble) 0);
		_tmp5_ = _tmp4_;
		_tmp6_ = g_date_time_format (_tmp5_, "%a");
		_tmp7_ = g_date_time_new_utc (1, 1, 2, 0, 0, (gdouble) 0);
		_tmp8_ = _tmp7_;
		_tmp9_ = g_date_time_format (_tmp8_, "%a");
		_tmp10_ = g_date_time_new_utc (1, 1, 3, 0, 0, (gdouble) 0);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_date_time_format (_tmp11_, "%a");
		_tmp13_ = g_date_time_new_utc (1, 1, 4, 0, 0, (gdouble) 0);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_date_time_format (_tmp14_, "%a");
		_tmp16_ = g_date_time_new_utc (1, 1, 5, 0, 0, (gdouble) 0);
		_tmp17_ = _tmp16_;
		_tmp18_ = g_date_time_format (_tmp17_, "%a");
		_tmp19_ = g_date_time_new_utc (1, 1, 6, 0, 0, (gdouble) 0);
		_tmp20_ = _tmp19_;
		_tmp21_ = g_date_time_format (_tmp20_, "%a");
		_tmp22_ = g_date_time_new_utc (1, 1, 7, 0, 0, (gdouble) 0);
		_tmp23_ = _tmp22_;
		_tmp24_ = g_date_time_format (_tmp23_, "%a");
		_tmp25_ = g_new0 (gchar*, 7 + 1);
		_tmp25_[0] = _tmp6_;
		_tmp25_[1] = _tmp9_;
		_tmp25_[2] = _tmp12_;
		_tmp25_[3] = _tmp15_;
		_tmp25_[4] = _tmp18_;
		_tmp25_[5] = _tmp21_;
		_tmp25_[6] = _tmp24_;
		clocks_utils_weekdays_abbreviations = (_vala_array_free (clocks_utils_weekdays_abbreviations, clocks_utils_weekdays_abbreviations_length1, (GDestroyNotify) g_free), NULL);
		clocks_utils_weekdays_abbreviations = _tmp25_;
		clocks_utils_weekdays_abbreviations_length1 = 7;
		_clocks_utils_weekdays_abbreviations_size_ = clocks_utils_weekdays_abbreviations_length1;
		_g_date_time_unref0 (_tmp23_);
		_g_date_time_unref0 (_tmp20_);
		_g_date_time_unref0 (_tmp17_);
		_g_date_time_unref0 (_tmp14_);
		_g_date_time_unref0 (_tmp11_);
		_g_date_time_unref0 (_tmp8_);
		_g_date_time_unref0 (_tmp5_);
	}
	_tmp26_ = clocks_utils_weekdays_abbreviations;
	_tmp26__length1 = clocks_utils_weekdays_abbreviations_length1;
	_tmp27_ = d;
	_tmp28_ = _tmp26_[_tmp27_];
	_tmp29_ = g_strdup (_tmp28_);
	result = _tmp29_;
	return result;
}


ClocksUtilsWeekdays* clocks_utils_weekdays_construct (GType object_type) {
	ClocksUtilsWeekdays* self = NULL;
	self = (ClocksUtilsWeekdays*) g_type_create_instance (object_type);
	return self;
}


ClocksUtilsWeekdays* clocks_utils_weekdays_new (void) {
	return clocks_utils_weekdays_construct (CLOCKS_UTILS_TYPE_WEEKDAYS);
}


static gboolean clocks_utils_weekdays_days_equal (ClocksUtilsWeekdays* self, gboolean* d, int d_length1) {
	gboolean result = FALSE;
	gboolean* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gboolean* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gboolean* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	gboolean* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	gint _tmp4_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = d;
	_tmp0__length1 = d_length1;
	_vala_assert (_tmp0__length1 == 7, "d.length == 7");
	_tmp1_ = d;
	_tmp1__length1 = d_length1;
	_tmp2_ = self->priv->days;
	_tmp2__length1 = self->priv->days_length1;
	_tmp3_ = self->priv->days;
	_tmp3__length1 = self->priv->days_length1;
	_tmp4_ = memcmp (_tmp1_, _tmp2_, (gsize) (_tmp3__length1 * sizeof (gboolean)));
	result = _tmp4_ == 0;
	return result;
}


gboolean clocks_utils_weekdays_get (ClocksUtilsWeekdays* self, ClocksUtilsWeekdaysDay d) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	ClocksUtilsWeekdaysDay _tmp1_ = 0;
	gboolean* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	ClocksUtilsWeekdaysDay _tmp4_ = 0;
	gboolean _tmp5_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = d;
	if (_tmp1_ >= 0) {
		ClocksUtilsWeekdaysDay _tmp2_ = 0;
		_tmp2_ = d;
		_tmp0_ = _tmp2_ < 7;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "d >= 0 && d < 7");
	_tmp3_ = self->priv->days;
	_tmp3__length1 = self->priv->days_length1;
	_tmp4_ = d;
	_tmp5_ = _tmp3_[_tmp4_];
	result = _tmp5_;
	return result;
}


void clocks_utils_weekdays_set (ClocksUtilsWeekdays* self, ClocksUtilsWeekdaysDay d, gboolean on) {
	gboolean _tmp0_ = FALSE;
	ClocksUtilsWeekdaysDay _tmp1_ = 0;
	gboolean* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	ClocksUtilsWeekdaysDay _tmp4_ = 0;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = d;
	if (_tmp1_ >= 0) {
		ClocksUtilsWeekdaysDay _tmp2_ = 0;
		_tmp2_ = d;
		_tmp0_ = _tmp2_ < 7;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "d >= 0 && d < 7");
	_tmp3_ = self->priv->days;
	_tmp3__length1 = self->priv->days_length1;
	_tmp4_ = d;
	_tmp5_ = on;
	_tmp3_[_tmp4_] = _tmp5_;
	_tmp6_ = _tmp3_[_tmp4_];
}


static void _vala_array_add1 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gchar* _vala_g_strjoinv (const gchar* separator, gchar** str_array, int str_array_length1) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	_tmp0_ = separator;
	if (_tmp0_ == NULL) {
		separator = "";
	}
	_tmp3_ = str_array;
	_tmp3__length1 = str_array_length1;
	if (_tmp3_ != NULL) {
		_tmp2_ = TRUE;
	} else {
		gchar** _tmp4_ = NULL;
		gint _tmp4__length1 = 0;
		_tmp4_ = str_array;
		_tmp4__length1 = str_array_length1;
		_tmp2_ = _tmp4__length1 > 0;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp5_ = FALSE;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		_tmp6_ = str_array;
		_tmp6__length1 = str_array_length1;
		if (_tmp6__length1 == -1) {
			gchar** _tmp7_ = NULL;
			gint _tmp7__length1 = 0;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = str_array;
			_tmp7__length1 = str_array_length1;
			_tmp8_ = _tmp7_[0];
			_tmp5_ = _tmp8_ != NULL;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp1_ = _tmp5_;
	}
	if (_tmp1_) {
		gint i = 0;
		gsize len = 0UL;
		gint _tmp31_ = 0;
		gint _tmp33_ = 0;
		gint _tmp34_ = 0;
		gsize _tmp35_ = 0UL;
		const gchar* _tmp36_ = NULL;
		gint _tmp37_ = 0;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		const gchar* res = NULL;
		gsize _tmp40_ = 0UL;
		void* _tmp41_ = NULL;
		void* ptr = NULL;
		const gchar* _tmp42_ = NULL;
		gchar** _tmp43_ = NULL;
		gint _tmp43__length1 = 0;
		const gchar* _tmp44_ = NULL;
		void* _tmp45_ = NULL;
		const gchar* _tmp62_ = NULL;
		len = (gsize) 1;
		{
			gboolean _tmp9_ = FALSE;
			i = 0;
			_tmp9_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gboolean _tmp12_ = FALSE;
				gchar** _tmp13_ = NULL;
				gint _tmp13__length1 = 0;
				gint _tmp21_ = 0;
				gchar** _tmp22_ = NULL;
				gint _tmp22__length1 = 0;
				gint _tmp23_ = 0;
				const gchar* _tmp24_ = NULL;
				gsize _tmp30_ = 0UL;
				if (!_tmp9_) {
					gint _tmp10_ = 0;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp9_ = FALSE;
				_tmp13_ = str_array;
				_tmp13__length1 = str_array_length1;
				if (_tmp13__length1 != -1) {
					gint _tmp14_ = 0;
					gchar** _tmp15_ = NULL;
					gint _tmp15__length1 = 0;
					_tmp14_ = i;
					_tmp15_ = str_array;
					_tmp15__length1 = str_array_length1;
					_tmp12_ = _tmp14_ < _tmp15__length1;
				} else {
					_tmp12_ = FALSE;
				}
				if (_tmp12_) {
					_tmp11_ = TRUE;
				} else {
					gboolean _tmp16_ = FALSE;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					_tmp17_ = str_array;
					_tmp17__length1 = str_array_length1;
					if (_tmp17__length1 == -1) {
						gchar** _tmp18_ = NULL;
						gint _tmp18__length1 = 0;
						gint _tmp19_ = 0;
						const gchar* _tmp20_ = NULL;
						_tmp18_ = str_array;
						_tmp18__length1 = str_array_length1;
						_tmp19_ = i;
						_tmp20_ = _tmp18_[_tmp19_];
						_tmp16_ = _tmp20_ != NULL;
					} else {
						_tmp16_ = FALSE;
					}
					_tmp11_ = _tmp16_;
				}
				if (!_tmp11_) {
					break;
				}
				_tmp22_ = str_array;
				_tmp22__length1 = str_array_length1;
				_tmp23_ = i;
				_tmp24_ = _tmp22_[_tmp23_];
				if (_tmp24_ != NULL) {
					gchar** _tmp25_ = NULL;
					gint _tmp25__length1 = 0;
					gint _tmp26_ = 0;
					const gchar* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					_tmp25_ = str_array;
					_tmp25__length1 = str_array_length1;
					_tmp26_ = i;
					_tmp27_ = _tmp25_[_tmp26_];
					_tmp28_ = strlen ((const gchar*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp21_ = _tmp29_;
				} else {
					_tmp21_ = 0;
				}
				_tmp30_ = len;
				len = _tmp30_ + _tmp21_;
			}
		}
		_tmp31_ = i;
		if (_tmp31_ == 0) {
			gchar* _tmp32_ = NULL;
			_tmp32_ = g_strdup ("");
			result = _tmp32_;
			return result;
		}
		_tmp33_ = i;
		str_array_length1 = _tmp33_;
		_tmp34_ = str_array_length1;
		_tmp35_ = len;
		_tmp36_ = separator;
		_tmp37_ = strlen ((const gchar*) _tmp36_);
		_tmp38_ = _tmp37_;
		_tmp39_ = i;
		len = _tmp35_ + (_tmp38_ * (_tmp39_ - 1));
		_tmp40_ = len;
		_tmp41_ = g_malloc (_tmp40_);
		res = _tmp41_;
		_tmp42_ = res;
		_tmp43_ = str_array;
		_tmp43__length1 = str_array_length1;
		_tmp44_ = _tmp43_[0];
		_tmp45_ = g_stpcpy ((void*) _tmp42_, (const gchar*) _tmp44_);
		ptr = _tmp45_;
		{
			gboolean _tmp46_ = FALSE;
			i = 1;
			_tmp46_ = TRUE;
			while (TRUE) {
				gint _tmp48_ = 0;
				gchar** _tmp49_ = NULL;
				gint _tmp49__length1 = 0;
				void* _tmp50_ = NULL;
				const gchar* _tmp51_ = NULL;
				void* _tmp52_ = NULL;
				const gchar* _tmp53_ = NULL;
				gchar** _tmp54_ = NULL;
				gint _tmp54__length1 = 0;
				gint _tmp55_ = 0;
				const gchar* _tmp56_ = NULL;
				void* _tmp60_ = NULL;
				void* _tmp61_ = NULL;
				if (!_tmp46_) {
					gint _tmp47_ = 0;
					_tmp47_ = i;
					i = _tmp47_ + 1;
				}
				_tmp46_ = FALSE;
				_tmp48_ = i;
				_tmp49_ = str_array;
				_tmp49__length1 = str_array_length1;
				if (!(_tmp48_ < _tmp49__length1)) {
					break;
				}
				_tmp50_ = ptr;
				_tmp51_ = separator;
				_tmp52_ = g_stpcpy (_tmp50_, (const gchar*) _tmp51_);
				ptr = _tmp52_;
				_tmp54_ = str_array;
				_tmp54__length1 = str_array_length1;
				_tmp55_ = i;
				_tmp56_ = _tmp54_[_tmp55_];
				if (_tmp56_ != NULL) {
					gchar** _tmp57_ = NULL;
					gint _tmp57__length1 = 0;
					gint _tmp58_ = 0;
					const gchar* _tmp59_ = NULL;
					_tmp57_ = str_array;
					_tmp57__length1 = str_array_length1;
					_tmp58_ = i;
					_tmp59_ = _tmp57_[_tmp58_];
					_tmp53_ = (const gchar*) _tmp59_;
				} else {
					_tmp53_ = "";
				}
				_tmp60_ = ptr;
				_tmp61_ = g_stpcpy (_tmp60_, _tmp53_);
				ptr = _tmp61_;
			}
		}
		_tmp62_ = res;
		res = NULL;
		result = (gchar*) _tmp62_;
		return result;
	} else {
		gchar* _tmp63_ = NULL;
		_tmp63_ = g_strdup ("");
		result = _tmp63_;
		return result;
	}
}


gchar* clocks_utils_weekdays_get_label (ClocksUtilsWeekdays* self) {
	gchar* result = NULL;
	gchar* r = NULL;
	gint n = 0;
	gint first = 0;
	gint _tmp8_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	r = NULL;
	n = 0;
	first = -1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_ = 0;
				gint _tmp3_ = 0;
				gboolean _tmp4_ = FALSE;
				if (!_tmp0_) {
					gint _tmp1_ = 0;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = i;
				if (!(_tmp2_ < 7)) {
					break;
				}
				_tmp3_ = i;
				_tmp4_ = clocks_utils_weekdays_get (self, (ClocksUtilsWeekdaysDay) _tmp3_);
				if (_tmp4_) {
					gint _tmp5_ = 0;
					gint _tmp7_ = 0;
					_tmp5_ = first;
					if (_tmp5_ < 0) {
						gint _tmp6_ = 0;
						_tmp6_ = i;
						first = _tmp6_;
					}
					_tmp7_ = n;
					n = _tmp7_ + 1;
				}
			}
		}
	}
	_tmp8_ = n;
	if (_tmp8_ == 0) {
		gchar* _tmp9_ = NULL;
		_tmp9_ = g_strdup ("");
		_g_free0 (r);
		r = _tmp9_;
	} else {
		gint _tmp10_ = 0;
		_tmp10_ = n;
		if (_tmp10_ == 1) {
			gint _tmp11_ = 0;
			gchar* _tmp12_ = NULL;
			_tmp11_ = first;
			_tmp12_ = clocks_utils_weekdays_plural ((ClocksUtilsWeekdaysDay) _tmp11_);
			_g_free0 (r);
			r = _tmp12_;
		} else {
			gint _tmp13_ = 0;
			_tmp13_ = n;
			if (_tmp13_ == 7) {
				const gchar* _tmp14_ = NULL;
				gchar* _tmp15_ = NULL;
				_tmp14_ = _ ("Every Day");
				_tmp15_ = g_strdup (_tmp14_);
				_g_free0 (r);
				r = _tmp15_;
			} else {
				gboolean _tmp16_ = FALSE;
				_tmp16_ = clocks_utils_weekdays_days_equal (self, CLOCKS_UTILS_WEEKDAYS_weekdays, G_N_ELEMENTS (CLOCKS_UTILS_WEEKDAYS_weekdays));
				if (_tmp16_) {
					const gchar* _tmp17_ = NULL;
					gchar* _tmp18_ = NULL;
					_tmp17_ = _ ("Weekdays");
					_tmp18_ = g_strdup (_tmp17_);
					_g_free0 (r);
					r = _tmp18_;
				} else {
					gboolean _tmp19_ = FALSE;
					_tmp19_ = clocks_utils_weekdays_days_equal (self, CLOCKS_UTILS_WEEKDAYS_weekends, G_N_ELEMENTS (CLOCKS_UTILS_WEEKDAYS_weekends));
					if (_tmp19_) {
						const gchar* _tmp20_ = NULL;
						gchar* _tmp21_ = NULL;
						_tmp20_ = _ ("Weekends");
						_tmp21_ = g_strdup (_tmp20_);
						_g_free0 (r);
						r = _tmp21_;
					} else {
						gchar** abbrs = NULL;
						gchar** _tmp22_ = NULL;
						gint abbrs_length1 = 0;
						gint _abbrs_size_ = 0;
						gchar** _tmp33_ = NULL;
						gint _tmp33__length1 = 0;
						gchar* _tmp34_ = NULL;
						_tmp22_ = g_new0 (gchar*, 0 + 1);
						abbrs = _tmp22_;
						abbrs_length1 = 0;
						_abbrs_size_ = abbrs_length1;
						{
							gint i = 0;
							i = 0;
							{
								gboolean _tmp23_ = FALSE;
								_tmp23_ = TRUE;
								while (TRUE) {
									gint _tmp25_ = 0;
									ClocksUtilsWeekdaysDay d = 0;
									ClocksUtilsWeekdaysDay _tmp26_ = 0;
									gint _tmp27_ = 0;
									ClocksUtilsWeekdaysDay _tmp28_ = 0;
									gboolean _tmp29_ = FALSE;
									if (!_tmp23_) {
										gint _tmp24_ = 0;
										_tmp24_ = i;
										i = _tmp24_ + 1;
									}
									_tmp23_ = FALSE;
									_tmp25_ = i;
									if (!(_tmp25_ < 7)) {
										break;
									}
									_tmp26_ = clocks_utils_weekdays_get_first_weekday ();
									_tmp27_ = i;
									d = (_tmp26_ + _tmp27_) % 7;
									_tmp28_ = d;
									_tmp29_ = clocks_utils_weekdays_get (self, _tmp28_);
									if (_tmp29_) {
										gchar** _tmp30_ = NULL;
										gint _tmp30__length1 = 0;
										ClocksUtilsWeekdaysDay _tmp31_ = 0;
										gchar* _tmp32_ = NULL;
										_tmp30_ = abbrs;
										_tmp30__length1 = abbrs_length1;
										_tmp31_ = d;
										_tmp32_ = clocks_utils_weekdays_abbreviation (_tmp31_);
										_vala_array_add1 (&abbrs, &abbrs_length1, &_abbrs_size_, _tmp32_);
									}
								}
							}
						}
						_tmp33_ = abbrs;
						_tmp33__length1 = abbrs_length1;
						_tmp34_ = _vala_g_strjoinv (", ", _tmp33_, _tmp33__length1);
						_g_free0 (r);
						r = _tmp34_;
						abbrs = (_vala_array_free (abbrs, abbrs_length1, (GDestroyNotify) g_free), NULL);
					}
				}
			}
		}
	}
	result = r;
	return result;
}


GVariant* clocks_utils_weekdays_serialize (ClocksUtilsWeekdays* self) {
	GVariant* result = NULL;
	GVariantBuilder* builder = NULL;
	GVariantType* _tmp0_ = NULL;
	GVariantType* _tmp1_ = NULL;
	GVariantBuilder* _tmp2_ = NULL;
	GVariantBuilder* _tmp3_ = NULL;
	gint32 i = 0;
	gboolean* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	GVariantBuilder* _tmp9_ = NULL;
	GVariant* _tmp10_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_variant_type_new ("ai");
	_tmp1_ = _tmp0_;
	_tmp2_ = g_variant_builder_new (_tmp1_);
	_tmp3_ = _tmp2_;
	_g_variant_type_free0 (_tmp1_);
	builder = _tmp3_;
	i = (gint32) 1;
	_tmp4_ = self->priv->days;
	_tmp4__length1 = self->priv->days_length1;
	{
		gboolean* d_collection = NULL;
		gint d_collection_length1 = 0;
		gint _d_collection_size_ = 0;
		gint d_it = 0;
		d_collection = _tmp4_;
		d_collection_length1 = _tmp4__length1;
		for (d_it = 0; d_it < _tmp4__length1; d_it = d_it + 1) {
			gboolean d = FALSE;
			d = d_collection[d_it];
			{
				gboolean _tmp5_ = FALSE;
				gint32 _tmp8_ = 0;
				_tmp5_ = d;
				if (_tmp5_) {
					GVariantBuilder* _tmp6_ = NULL;
					gint32 _tmp7_ = 0;
					_tmp6_ = builder;
					_tmp7_ = i;
					g_variant_builder_add (_tmp6_, "i", _tmp7_, NULL);
				}
				_tmp8_ = i;
				i = _tmp8_ + 1;
			}
		}
	}
	_tmp9_ = builder;
	_tmp10_ = g_variant_builder_end (_tmp9_);
	g_variant_ref_sink (_tmp10_);
	result = _tmp10_;
	_g_variant_builder_unref0 (builder);
	return result;
}


ClocksUtilsWeekdays* clocks_utils_weekdays_deserialize (GVariant* days_variant) {
	ClocksUtilsWeekdays* result = NULL;
	ClocksUtilsWeekdays* d = NULL;
	ClocksUtilsWeekdays* _tmp0_ = NULL;
	g_return_val_if_fail (days_variant != NULL, NULL);
	_tmp0_ = clocks_utils_weekdays_new ();
	d = _tmp0_;
	{
		GVariantIter* _v_it = NULL;
		GVariant* _tmp1_ = NULL;
		GVariantIter* _tmp2_ = NULL;
		GVariant* v = NULL;
		_tmp1_ = days_variant;
		_tmp2_ = g_variant_iter_new (_tmp1_);
		_v_it = _tmp2_;
		while (TRUE) {
			GVariantIter* _tmp3_ = NULL;
			GVariant* _tmp4_ = NULL;
			GVariant* _tmp5_ = NULL;
			gint32 i = 0;
			GVariant* _tmp6_ = NULL;
			gint32 _tmp7_ = 0;
			gboolean _tmp8_ = FALSE;
			gint32 _tmp9_ = 0;
			_tmp3_ = _v_it;
			_tmp4_ = g_variant_iter_next_value (_tmp3_);
			_g_variant_unref0 (v);
			v = _tmp4_;
			_tmp5_ = v;
			if (!(_tmp5_ != NULL)) {
				break;
			}
			_tmp6_ = v;
			_tmp7_ = g_variant_get_int32 (_tmp6_);
			i = _tmp7_;
			_tmp9_ = i;
			if (_tmp9_ > ((gint32) 0)) {
				gint32 _tmp10_ = 0;
				_tmp10_ = i;
				_tmp8_ = _tmp10_ <= ((gint32) 7);
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				ClocksUtilsWeekdays* _tmp11_ = NULL;
				gint32 _tmp12_ = 0;
				_tmp11_ = d;
				_tmp12_ = i;
				clocks_utils_weekdays_set (_tmp11_, (ClocksUtilsWeekdaysDay) (_tmp12_ - 1), TRUE);
			} else {
				gint32 _tmp13_ = 0;
				_tmp13_ = i;
				g_warning ("utils.vala:294: Invalid days %d", (gint) _tmp13_);
			}
		}
		_g_variant_unref0 (v);
		_g_variant_iter_free0 (_v_it);
	}
	result = d;
	return result;
}


gboolean clocks_utils_weekdays_get_empty (ClocksUtilsWeekdays* self) {
	gboolean result;
	gboolean* _tmp0_ = NULL;
	gboolean* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = g_new0 (gboolean, 7);
	_tmp0_[0] = FALSE;
	_tmp0_[1] = FALSE;
	_tmp0_[2] = FALSE;
	_tmp0_[3] = FALSE;
	_tmp0_[4] = FALSE;
	_tmp0_[5] = FALSE;
	_tmp0_[6] = FALSE;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = 7;
	_tmp2_ = clocks_utils_weekdays_days_equal (self, _tmp1_, 7);
	_tmp3_ = _tmp2_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp3_;
	return result;
}


static void clocks_utils_value_weekdays_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void clocks_utils_value_weekdays_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		clocks_utils_weekdays_unref (value->data[0].v_pointer);
	}
}


static void clocks_utils_value_weekdays_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = clocks_utils_weekdays_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer clocks_utils_value_weekdays_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* clocks_utils_value_weekdays_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ClocksUtilsWeekdays* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = clocks_utils_weekdays_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* clocks_utils_value_weekdays_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ClocksUtilsWeekdays** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = clocks_utils_weekdays_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* clocks_utils_param_spec_weekdays (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ClocksUtilsParamSpecWeekdays* spec;
	g_return_val_if_fail (g_type_is_a (object_type, CLOCKS_UTILS_TYPE_WEEKDAYS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer clocks_utils_value_get_weekdays (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CLOCKS_UTILS_TYPE_WEEKDAYS), NULL);
	return value->data[0].v_pointer;
}


void clocks_utils_value_set_weekdays (GValue* value, gpointer v_object) {
	ClocksUtilsWeekdays* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CLOCKS_UTILS_TYPE_WEEKDAYS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CLOCKS_UTILS_TYPE_WEEKDAYS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		clocks_utils_weekdays_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		clocks_utils_weekdays_unref (old);
	}
}


void clocks_utils_value_take_weekdays (GValue* value, gpointer v_object) {
	ClocksUtilsWeekdays* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, CLOCKS_UTILS_TYPE_WEEKDAYS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, CLOCKS_UTILS_TYPE_WEEKDAYS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		clocks_utils_weekdays_unref (old);
	}
}


static void clocks_utils_weekdays_class_init (ClocksUtilsWeekdaysClass * klass) {
	clocks_utils_weekdays_parent_class = g_type_class_peek_parent (klass);
	((ClocksUtilsWeekdaysClass *) klass)->finalize = clocks_utils_weekdays_finalize;
	g_type_class_add_private (klass, sizeof (ClocksUtilsWeekdaysPrivate));
}


static void clocks_utils_weekdays_instance_init (ClocksUtilsWeekdays * self) {
	gboolean* _tmp0_ = NULL;
	self->priv = CLOCKS_UTILS_WEEKDAYS_GET_PRIVATE (self);
	_tmp0_ = g_new0 (gboolean, 7);
	_tmp0_[0] = FALSE;
	_tmp0_[1] = FALSE;
	_tmp0_[2] = FALSE;
	_tmp0_[3] = FALSE;
	_tmp0_[4] = FALSE;
	_tmp0_[5] = FALSE;
	_tmp0_[6] = FALSE;
	self->priv->days = _tmp0_;
	self->priv->days_length1 = 7;
	self->priv->_days_size_ = self->priv->days_length1;
	self->ref_count = 1;
}


static void clocks_utils_weekdays_finalize (ClocksUtilsWeekdays* obj) {
	ClocksUtilsWeekdays * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CLOCKS_UTILS_TYPE_WEEKDAYS, ClocksUtilsWeekdays);
	g_signal_handlers_destroy (self);
	self->priv->days = (g_free (self->priv->days), NULL);
}


GType clocks_utils_weekdays_get_type (void) {
	static volatile gsize clocks_utils_weekdays_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_utils_weekdays_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { clocks_utils_value_weekdays_init, clocks_utils_value_weekdays_free_value, clocks_utils_value_weekdays_copy_value, clocks_utils_value_weekdays_peek_pointer, "p", clocks_utils_value_weekdays_collect_value, "p", clocks_utils_value_weekdays_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ClocksUtilsWeekdaysClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) clocks_utils_weekdays_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClocksUtilsWeekdays), 0, (GInstanceInitFunc) clocks_utils_weekdays_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType clocks_utils_weekdays_type_id;
		clocks_utils_weekdays_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ClocksUtilsWeekdays", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&clocks_utils_weekdays_type_id__volatile, clocks_utils_weekdays_type_id);
	}
	return clocks_utils_weekdays_type_id__volatile;
}


gpointer clocks_utils_weekdays_ref (gpointer instance) {
	ClocksUtilsWeekdays* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void clocks_utils_weekdays_unref (gpointer instance) {
	ClocksUtilsWeekdays* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		CLOCKS_UTILS_WEEKDAYS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


ClocksUtilsBell* clocks_utils_bell_construct (GType object_type, const gchar* soundid) {
	ClocksUtilsBell * self = NULL;
	GSettings* _tmp0_ = NULL;
	GSettings* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	GCancellable* _tmp10_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (soundid != NULL, NULL);
	self = (ClocksUtilsBell*) g_object_new (object_type, NULL);
	_tmp0_ = g_settings_new ("org.gnome.desktop.sound");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp0_;
	{
		GSoundContext* _tmp1_ = NULL;
		GSoundContext* _tmp2_ = NULL;
		GSoundContext* _tmp3_ = NULL;
		_tmp2_ = gsound_context_new (NULL, &_inner_error_);
		_tmp1_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
		_tmp3_ = _tmp1_;
		_tmp1_ = NULL;
		_g_object_unref0 (self->priv->gsound);
		self->priv->gsound = _tmp3_;
		_g_object_unref0 (_tmp1_);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("utils.vala:314: Sound could not be initialized, error: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp6_ = self->priv->settings;
	_tmp7_ = g_settings_get_string (_tmp6_, "theme-name");
	_g_free0 (self->priv->soundtheme);
	self->priv->soundtheme = _tmp7_;
	_tmp8_ = soundid;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 (self->priv->sound);
	self->priv->sound = _tmp9_;
	_tmp10_ = g_cancellable_new ();
	_g_object_unref0 (self->priv->cancellable);
	self->priv->cancellable = _tmp10_;
	return self;
}


ClocksUtilsBell* clocks_utils_bell_new (const gchar* soundid) {
	return clocks_utils_bell_construct (CLOCKS_UTILS_TYPE_BELL, soundid);
}


static void clocks_utils_bell_ring_real_data_free (gpointer _data) {
	ClocksUtilsBellRingRealData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (ClocksUtilsBellRingRealData, _data_);
}


static void clocks_utils_bell_ring_real (ClocksUtilsBell* self, gboolean repeat, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	ClocksUtilsBellRingRealData* _data_;
	ClocksUtilsBell* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	_data_ = g_slice_new0 (ClocksUtilsBellRingRealData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, clocks_utils_bell_ring_real);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, clocks_utils_bell_ring_real_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = repeat;
	_data_->repeat = _tmp1_;
	clocks_utils_bell_ring_real_co (_data_);
}


static void clocks_utils_bell_ring_real_finish (ClocksUtilsBell* self, GAsyncResult* _res_) {
	ClocksUtilsBellRingRealData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void clocks_utils_bell_ring_real_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	ClocksUtilsBellRingRealData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	clocks_utils_bell_ring_real_co (_data_);
}


static gboolean clocks_utils_bell_ring_real_co (ClocksUtilsBellRingRealData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->gsound;
	if (_data_->_tmp0_ == NULL) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	{
		{
			_data_->_tmp1_ = TRUE;
			while (TRUE) {
				if (!_data_->_tmp1_) {
					_data_->_tmp2_ = FALSE;
					_data_->_tmp2_ = _data_->repeat;
					if (!_data_->_tmp2_) {
						break;
					}
				}
				_data_->_tmp1_ = FALSE;
				_data_->_tmp3_ = NULL;
				_data_->_tmp3_ = _data_->self->priv->gsound;
				_data_->_tmp4_ = NULL;
				_data_->_tmp4_ = _data_->self->priv->cancellable;
				_data_->_tmp5_ = NULL;
				_data_->_tmp5_ = _data_->self->priv->sound;
				_data_->_tmp6_ = NULL;
				_data_->_tmp6_ = _data_->self->priv->soundtheme;
				_data_->_state_ = 1;
				gsound_context_play_full (_data_->_tmp3_, _data_->_tmp4_, clocks_utils_bell_ring_real_ready, _data_, GSOUND_ATTR_EVENT_ID, _data_->_tmp5_, GSOUND_ATTR_CANBERRA_XDG_THEME_NAME, _data_->_tmp6_, GSOUND_ATTR_MEDIA_ROLE, "alarm", NULL);
				return FALSE;
				_state_1:
				gsound_context_play_full_finish (_data_->_tmp3_, _data_->_res_, &_data_->_inner_error_);
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					if (g_error_matches (_data_->_inner_error_, G_IO_ERROR, G_IO_ERROR_CANCELLED)) {
						goto __catch6_g_io_error_cancelled;
					}
					goto __catch6_g_error;
				}
			}
		}
	}
	goto __finally6;
	__catch6_g_io_error_cancelled:
	{
		_data_->e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_g_error_free0 (_data_->e);
	}
	goto __finally6;
	__catch6_g_error:
	{
		_data_->_vala1_e = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp7_ = NULL;
		_data_->_tmp7_ = _data_->_vala1_e;
		_data_->_tmp8_ = NULL;
		_data_->_tmp8_ = _data_->_tmp7_->message;
		g_warning ("utils.vala:337: Error playing sound: %s", _data_->_tmp8_);
		_g_error_free0 (_data_->_vala1_e);
	}
	__finally6:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void clocks_utils_bell_ring_once (ClocksUtilsBell* self) {
	g_return_if_fail (self != NULL);
	clocks_utils_bell_ring_real (self, FALSE, NULL, NULL);
}


void clocks_utils_bell_ring (ClocksUtilsBell* self) {
	g_return_if_fail (self != NULL);
	clocks_utils_bell_ring_real (self, TRUE, NULL, NULL);
}


void clocks_utils_bell_stop (ClocksUtilsBell* self) {
	GCancellable* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->cancellable;
	g_cancellable_cancel (_tmp0_);
}


static void clocks_utils_bell_class_init (ClocksUtilsBellClass * klass) {
	clocks_utils_bell_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ClocksUtilsBellPrivate));
	G_OBJECT_CLASS (klass)->finalize = clocks_utils_bell_finalize;
}


static void clocks_utils_bell_instance_init (ClocksUtilsBell * self) {
	self->priv = CLOCKS_UTILS_BELL_GET_PRIVATE (self);
}


static void clocks_utils_bell_finalize (GObject* obj) {
	ClocksUtilsBell * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, CLOCKS_UTILS_TYPE_BELL, ClocksUtilsBell);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->gsound);
	_g_object_unref0 (self->priv->cancellable);
	_g_free0 (self->priv->soundtheme);
	_g_free0 (self->priv->sound);
	G_OBJECT_CLASS (clocks_utils_bell_parent_class)->finalize (obj);
}


GType clocks_utils_bell_get_type (void) {
	static volatile gsize clocks_utils_bell_type_id__volatile = 0;
	if (g_once_init_enter (&clocks_utils_bell_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ClocksUtilsBellClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) clocks_utils_bell_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ClocksUtilsBell), 0, (GInstanceInitFunc) clocks_utils_bell_instance_init, NULL };
		GType clocks_utils_bell_type_id;
		clocks_utils_bell_type_id = g_type_register_static (G_TYPE_OBJECT, "ClocksUtilsBell", &g_define_type_info, 0);
		g_once_init_leave (&clocks_utils_bell_type_id__volatile, clocks_utils_bell_type_id);
	}
	return clocks_utils_bell_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



